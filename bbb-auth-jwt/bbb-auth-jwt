#! /usr/bin/python3
#
# A FastCGI script used to authenticate users into Big Blue Button
# using a JSON web token signed with either the Big Blue Button API
# key, or an RSA key from /etc/bigbluebutton/authorized_keys
#
# Such tokens are generated by the bbb-mklogin script.
#
# In addition to the standard JWT claims 'sub' (Subject) and 'exp',
# we also require 'role' (either 'm' for moderator or 'v' for viewer).
#
# Optional claim: 'mtg' for meeting ID (default is hostname)
#
# Moderators will start the meeting when they enter.  Viewers will
# get an error message if the meeting isn't already running.
#
# If /etc/bigbluebutton/bbb-redirect.py exists, it will be read
# and exec-ed by this script, allowing the administrator
# to set redirect() and rewrite() functions.

import os
import re
import sys
import jwt
import socket
import traceback
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

try:
    import bigbluebutton
except ImportError:
    bigbluebutton = None

# If stdin is /dev/null, we probably started from systemd and are a FastCGI script.
# Certainly, if we're a standard CGI script, then stdin is talking to the web server.

use_fastcgi = bool(os.stat('/dev/null') == os.stat('/dev/stdin'))

# The main role of loading this file is to define a 'redirect'
# function that accepts a JSON web token and returns either None (to
# open a local session), or a redirect URL.  We can also define a
# 'rewrite' function to modify a decoded JWT if the 'redirect'
# function declined to do anything with it.

def redirect(JWT):
    return None

def rewrite(decoded):
    pass

try:
    exec(open('/etc/bigbluebutton/bbb-redirect.py').read())
except:
    pass

# These passwords don't have to be very secure because the API key
# is what really protects everything.  If you have the API key
# can get these passwords from the meeting's XML data anyway.

moderatorPW = 'jidtyv7RG8g0gsGMLq5M'
attendeePW = 'aQxdAAEi2fQq27TB6rTf'

# maps first letter of 'role' claim to the join password to be used
role_password = {'m' : moderatorPW,
                 'a' : attendeePW,
                 'v' : attendeePW,
}

def authorized_keys():
    if not hasattr(authorized_keys, 'retval'):
        authorized_keys.retval = []
        try:
            with open('/etc/bigbluebutton/authorized_keys') as f:
                for line in f.read().split('\n'):
                    try:
                        authorized_keys.retval.append(serialization.load_ssh_public_key(line.encode(), backend=default_backend()))
                    except:
                        pass
        except:
            pass
    return authorized_keys.retval

# FASTCGI server / CGI script

def login():
    try:
        JWT = os.environ['REQUEST_URI'].split('/')[-1]

        decoded = None

        for key in authorized_keys():
            try:
                decoded = jwt.decode(jwt = JWT, key = key, algorithms = ['RS512'])
            except (jwt.InvalidSignatureError, TypeError):
                pass

        # The server's API key is the last key we'll try.  If it
        # throws an error, then we'll just let it propagate up.

        if not decoded and bigbluebutton:
            decoded = jwt.decode(jwt = JWT, key = bigbluebutton.securitySalt(), algorithms = ['HS256'])

        # At this point, we've successfully decoded and verified a JSON web token.

        # Check first to see if our redirect function wants to send us somewhere else.

        url = redirect(JWT)
        if url:
            print(f"Location: {url}\n")
            return

        if not bigbluebutton:
            # We tried to import it at the start of the script, but
            # now we actually need it, so just error out at this point
            # if it isn't here.
            raise ImportError('bigbluebutton')

        rewrite(decoded)

        fullName = decoded['sub']
        if 'mtg' in decoded:
            meetingID = decoded['mtg']
        else:
            meetingID = socket.gethostname()
        roomName = meetingID

        password = role_password[decoded['role'].lower()[0]]

        # This API call will quietly fail if the meeting is already running.
        if password == moderatorPW:
            bigbluebutton.create(name = roomName,
                                 meetingID = meetingID,
                                 attendeePW = attendeePW,
                                 moderatorPW = moderatorPW,
                                 isBreakoutRoom = False,
            )

        if False:
            # using redirect = False and using the URL from the XML
            # seems to be buggy right now (2.3.0~alpha7)
            response = bigbluebutton.join(meetingID = meetingID,
                                          fullName = fullName,
                                          password = password,
                                          redirect = False,
            )

            url = response.xpath('.//url')[0].text
            print(f"Location: {url}\n")
        else:
            # to evade the bug, use an internal package function to
            # construct the join URL without calling it, then redirect
            # to that URL instead
            response = bigbluebutton._APIurl('join', {'meetingID': meetingID,
                                                      'fullName': fullName,
                                                      'password': password,
                                                      'redirect': 'true',
            })
            print(f"Location: {response}\n")

    except Exception as ex:
        print(ex, file=sys.stderr)
        sys.stderr.flush()
        print(f"""Content-type: text/html

<HTML>
<HEAD>
<TITLE>Login Failed</TITLE>
</HEAD>
<BODY>
<CENTER><H3>Login Failed</H3></CENTER>

Something went wrong!

<PRE>
{ex}

{traceback.format_exc()}
</PRE>
</BODY>
</HTML>
""")


if not use_fastcgi:
    login()
    exit(0)

import fastcgi
@fastcgi.fastcgi(sock='/run/bbb-auth-jwt/fastcgi.sock')
def fastcgi_login():
    login()
